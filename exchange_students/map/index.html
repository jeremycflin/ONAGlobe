<!DOCTYPE html>
<meta charset='utf-8'>
<style>
/*
.states {
  fill: #ccc;
}

.state-borders {
  fill: none;
  stroke: #fff;
  stroke-width: 1.5px;
  stroke-linejoin: round;
  stroke-linecap: round;
}

.airport-arcs {
  display: none;
  fill: none;
  stroke: #000;
}

.airport-cell {
  fill: none;
  pointer-events: all;
}

.airports circle {
  fill: steelblue;
  stroke: #fff;
  pointer-events: none;
}

.airport:hover .airport-arcs {
  display: inline;
}

svg:not(:hover) .airport-cell {
  stroke: #000;
  stroke-opacity: .2;
}*/

.baseMap{
  stroke-width:0.8px;
  stroke:white;
  fill:#E4E5E6;
  opacity:0.8;
}

.cities_start{
  fill:rgba(199,70,70,.8);
}

.cities_end{
  fill:rgba(29, 168, 183, 1);
  }

.line{
  stroke:rgba(0, 0, 0, 0.6);
  stroke-width:3px;
  fill:none;
  stroke-dasharray:3, 3;
}

.geo-globe {
  fill: rgba(203,220,234,0.4);
/*  fill:white;
*/    }


</style>
<body>
<script src='https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/queue-async/1.0.7/queue.min.js'></script>
<script src='https://cdnjs.cloudflare.com/ajax/libs/topojson/1.6.19/topojson.min.js'></script>
<script src='arc.js/arc.js'></script>
<div id='map'>
<script>
////////////////////////////////
////////////////////////////////  
// preparation: svg's width/height, projection, path, voronoi
////////////////////////////////
////////////////////////////////

// I followed Mike Bostock's margin convention to set margins first, 
// and then set the width and height based on margins.
// Here's the link to the margin convention 
// http://bl.ocks.org/mbostock/3019563

var margin = {top: 30, right: 30, bottom: 30, left: 30},
  width = 800 - margin.left - margin.right,
  height = 600 - margin.top - margin.bottom;

// var projection = d3.geo.mercator()
//   // .center([121.0, 23.5])
//   .translate([width / 2, height / 1.5])
//   .scale(125); // feel free to tweak the number for scale and see the changes

var projection =  d3.geo.orthographic().scale(280).translate([400,300]).clipAngle(90).precision(0.5);

var path = d3.geo.path()
  .projection(projection);

// Create a voronoi layer for better mouse interaction experience
// For more reading on voronoi, check out 
// http://www.visualcinnamon.com/2015/07/voronoi.html

var voronoi = d3.geom.voronoi()
  .x(function(d) { return d.x; })
  .y(function(d) { return d.y; })
  .clipExtent([[0, 0], [width, height]]);

var svg = d3.select('#map').append('svg')
  .attr('width', width + margin.left + margin.right)
  .attr('height', height + margin.top + margin.bottom)
  .attr('class', 'graph-svg-component')
  .call(responsivefy)// Call function responsivefy to make the graphic reponsive according to the window width/height
  .append('g')
  .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

var backgroundCircle = svg.append("circle")
      .attr('cx', width / 1.85)
      .attr('cy', height / 1.84099)
      .attr('r', 0)
      .attr('class', 'geo-globe');

backgroundCircle.attr('r', projection.scale() );

var cities_start = [
  {'name': 'Taipei',
   'location':[23.5000,121.0000]
  },
  {'name': 'Taipei',
   'location':[23.5000,121.0000]
  }
]

var cities_end = [
  {
    'name':'Berkeley',
    'location':[37.8717,-122.2728]
  },
  {
    'name':'Berkeley',
    'location':[35.8592948,104.1361117]
  }
]


////////////////////////////////
////////////////////////////////  
// Queue: queue is an asynchronous helper library for JavaScrip 
// It helps coders to easily load multiple datasets 
// Here's the link to queue github repository:
// https://github.com/mbostock/queue
////////////////////////////////
////////////////////////////////

queue()
    .defer(d3.json, 'data/world_countries.json')// load geojson/topojson data
    // .defer(d3.csv, 'airports.csv')
    // .defer(d3.csv, 'flights.csv')
    .await(ready);

var startX;
var startY;
var endX;
var endY;

startX = cities_start[0].location[1]
startY = cities_start[0].location[0]

endX = cities_end[0].location[1]
endY =cities_end[0].location[0]

var start = { x: startX, y: startY };
var end = { x: endX, y: endY };
var generator = new arc.GreatCircle(start, end, {'name': 'Taipei to Berkeley'});
var line = generator.Arc(100,{offset:10});

// var flightline = d3.svg.line()
//     // .interpolate("basis") 
//     .x(function(d) { console.log(d); return projection(d.geometries.coords) })
//     .y(function(d) { return projection(d.geometries.coords) });

function ready(error, world) {
  if (error) throw error;
  svg.selectAll('path')
     .data(world.features)
     .enter()
     .append('path')
     .attr('d', path)
     // .append("g")
     .attr('class','baseMap');

  svg.selectAll('.cities_start')
     .data(cities_start)
     .enter()
     .append('circle')
     .attr('cx', function(d){ return projection([d.location[1], d.location[0]])[0]; } ) //projection([long, lat])[1]
     .attr('cy', function(d){ return projection([d.location[1], d.location[0]])[1]; })
     .attr('r', '3')
     // .append("g")
     .attr('class','cities_start');

  svg.selectAll('.cities_end')
     .data(cities_end)
     .enter()
     .append('circle')
     .attr('cx', function(d){ return projection([d.location[1], d.location[0]])[0]; } ) //projection([long, lat])[1]
     .attr('cy', function(d){ return projection([d.location[1], d.location[0]])[1]; })
     .attr('r', '3')
     // .append("g")
     .attr('class','cities_end');

  svg.append("g")
     .attr("class", "line")
     .selectAll(".arcs")
     .data([line.json()])
     .enter()
     .append("path")
     .attr("d", path); 




  

  // var airportById = d3.map(),
  //     positions = [];

  // airports.forEach(function(d) {
  //   airportById.set(d.iata, d);'
  //   d.outgoing = [];
  //   d.incoming = [];
  // });

  // flights.forEach(function(flight) {
  //   var source = airportById.get(flight.origin),
  //       target = airportById.get(flight.destination),
  //       link = {source: source, target: target};
  //   source.outgoing.push(link);
  //   target.incoming.push(link);
  // });

  // airports = airports.filter(function(d) {
  //   if (d.count = Math.max(d.incoming.length, d.outgoing.length)) {
  //     d[0] = +d.longitude;
  //     d[1] = +d.latitude;
  //     var position = projection(d);
  //     d.x = position[0];
  //     d.y = position[1];
  //     return true;
  //   }
  // });

  // voronoi(airports)
  //     .forEach(function(d) { d.point.cell = d; });

  // svg.append('path')
  //     .datum(topojson.feature(us, us.objects.land))
  //     .attr('class', 'states')
  //     .attr('d', path);

  // svg.append('path')
  //     .datum(topojson.mesh(us, us.objects.states, function(a, b) { return a !== b; }))
  //     .attr('class', 'state-borders')
  //     .attr('d', path);

  // var airport = svg.append('g')
  //     .attr('class', 'airports')
  //   .selectAll('g')
  //     .data(airports.sort(function(a, b) { return b.count - a.count; }))
  //   .enter().append('g')
  //     .attr('class', 'airport');

  // airport.append('path')
  //     .attr('class', 'airport-cell')
  //     .attr('d', function(d) { return d.cell.length ? 'M' + d.cell.join('L') + 'Z' : null; });

  // airport.append('g')
  //     .attr('class', 'airport-arcs')
  //   .selectAll('path')
  //     .data(function(d) { return d.outgoing; })
  //   .enter().append('path')
  //     .attr('d', function(d) { return path({type: 'LineString', coordinates: [d.source, d.target]}); });

  // airport.append('circle')
  //     .attr('transform', function(d) { return 'translate(' + d.x + ',' + d.y + ')'; })
  //     .attr('r', function(d, i) { return Math.sqrt(d.count); });

}

 d3.select("svg").call( //drag on the svg element
    d3.behavior.drag()
      .origin(function() {
        var r = projection.rotate(); 
        return {x: r[0], y: -r[1]}; //starting point
      })
      .on("drag", function() {
        var r = projection.rotate();
        /* update retation angle */
        projection.rotate([d3.event.x, -d3.event.y, r[2]]);
        /* redraw the map and circles after rotation */
        svg.selectAll("path").attr("d",path);
        svg.selectAll(".cities_start")
          .attr('cx', function(d){ return projection([d.location[1], d.location[0]])[0]; } ) //projection([long, lat])[1]
          .attr('cy', function(d){ return projection([d.location[1], d.location[0]])[1]; });
        svg.selectAll(".cities_end")
          .attr('cx', function(d){ return projection([d.location[1], d.location[0]])[0]; } ) //projection([long, lat])[1]
          .attr('cy', function(d){ return projection([d.location[1], d.location[0]])[1]; })


      })
  );

  function responsivefy(svg) {
            var container = d3.select(svg.node().parentNode),
                width = parseInt(svg.style('width')),
                height = parseInt(svg.style('height')),
                aspect = width / height;

            svg.attr('viewBox', '0 0 ' + width + ' ' + height)
                .attr('perserveAspectRatio', 'xMinYMid')
                .call(resize);

            d3.select(window).on('resize', resize);

            function resize() {
                var targetWidth = parseInt(container.style('width'));
                svg.attr('width', targetWidth);
                svg.attr('height', Math.round(targetWidth / aspect));
            }
        }

</script>